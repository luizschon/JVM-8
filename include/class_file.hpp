#ifndef _CLASS_FILE_HPP
#define _CLASS_FILE_HPP

#include "types_definition.hpp"
#include "constant_pool_info.hpp"
#include <iostream>

using namespace std;

// Class Access Flags
#define ACC_PUBLIC     0x0001 // Declared public; may be accessed from outside its package
#define ACC_FINAL      0x0010 // Declared final; no subclasses allowed.
#define ACC_SUPER      0x0020 // Treat superclass methods specially when invoked by the invokespecial instruction.
#define ACC_INTERFACE  0x0200 // Is an interface, not a class.
#define ACC_ABSTRACT   0x0400 // Declared abstract; must not be instantiated
#define ACC_SYNTHETIC  0x1000 // Declared synthetic; not present in the source code.
#define ACC_ANNOTATION 0x2000 // Declared as an annotation type.
#define ACC_ENUM       0x4000 // Declared as an enum type.

// Field Access and property flags
#define ACC_PUBLIC    0x0001 // Declared public; may be accessed from outside its package.
#define ACC_PRIVATE   0x0002 // Declared private; usable only within the defining class.
#define ACC_PROTECTED 0x0004 // Declared protected; may be accessed within Subclasses.
#define ACC_STATIC    0x0008 // Declared static.
#define ACC_FINAL     0x0010 // Declared final; never directly assigned to after Object construction.
#define ACC_VOLATILE  0x0040 // Declared volatile; cannot be cached.
#define ACC_TRANSIENT 0x0080 // Declared transient; not written or read by a persistent object manager.
#define ACC_SYNTHETIC 0x1000 // Declared synthetic; not present in the source code.
#define ACC_ENUM      0x4000 // Declared as an element of an enum.

// Method Access and Property Flags
#define ACC_PUBLIC       0x0001 // Declared public; may be accessed from outside its package.
#define ACC_PRIVATE      0x0002 // Declared private; accessible only within the defining class.
#define ACC_PROTECTED    0x0004 // Declared protected; may be accessed withinsubclasses.
#define ACC_STATIC       0x0008 // Declared static.
#define ACC_FINAL        0x0010 // Declared final; must not be overridden.
#define ACC_SYNCHRONIZED 0x0020 // Declared synchronized; invocation is wrapped by a monitor use.
#define ACC_BRIDGE       0x0040 // A bridge method, generated by the compiler.
#define ACC_VARARGS      0x0080 // Declared with variable number of arguments.
#define ACC_NATIVE       0x0100 // Declared native; implemented in a language other than Java.
#define ACC_ABSTRACT     0x0400 // Declared abstract; no implementation is provided.
#define ACC_STRICT       0x0800 // Declared strictfp; floating-point mode is FP-strict.
#define ACC_SYNTHETIC    0x1000 // Declared synthetic; not present in the source code.

// Attributes Info Structure
typedef struct attr_info {
    attr_info(ifstream &file);
    attr_info(bytestream_it &iterator);
    u2 attr_name_idx;
    u4 attr_length;
    vector<u1> info;
} attr_info;

// Field Info Structure
typedef struct field_info {
    field_info(ifstream &file);
    u2 access_flags;
    u2 name_idx;
    u2 descriptor_idx;
    u2 attr_count;
    vector<attr_info> attr;
} field_info;

// Method Info Structure
typedef struct method_info {
    method_info(ifstream &file);
    u2 access_flags;
    u2 name_idx;
    u2 descriptor_idx;
    u2 attr_count;
    vector<attr_info> attr;
} method_info;

// The Class File Structure
typedef struct class_file {
    u4 magic;
    u2 minor_version;
    u2 major_version;
    u2 constant_pool_count;
    cp_info_vector constant_pool;
    u2 access_flag;
    u2 this_class;
    u2 super_class;
    u2 interfaces_count;
    vector<u2> interfaces;
    u2 fields_count;
    vector<field_info> fields;
    u2 methods_count;
    vector<method_info> methods;
    u2 attributes_count;
    vector<attr_info> attributes;
} class_file;

// A template to read u1, u2, u4 or u8 bytes in big-endian order
template <typename T>
T read_bytes(ifstream &file) 
{
    u1 byte = 0;
    T data = 0;
    for (int i = 0; i < sizeof(T); i++) 
    {
        file.read(reinterpret_cast<char*>(&byte), sizeof(byte));
        data <<= 8;
        data |= byte;
    }
    return data;
}

// A template to convert u1, u2, u4 or u8 bytes to little-endian order
template <typename T>
T get_bytes(bytestream_it &iterator)
{
    T return_value = 0;
    for (int i = 1; i <= sizeof(T); i++)
    {
        return_value <<= 8;
        return_value |= *iterator;
        iterator++;
    }
    return return_value;
}

/**
 * @brief Stores the magic, major and minor values from input file in the class file
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_metadata(class_file &class_f, ifstream &file);

/**
 * @brief Stores the constant pool values from input file in the class file 
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_constant_pool(class_file &class_f, ifstream &file);

/**
 * @brief Opens an input file and returns a file stream
 * 
 * @param argc number of command line arguments
 * @param argv the file name
 * @return ifstream a stream of the input file
 */
ifstream open_file(int argc, char** argv);

/**
 * @brief Stores the access_flag, this_flag, super_class values from input file
 * in the class file and call remaining methods
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_class_data(class_file &class_f, ifstream &file);

/**
 * @brief Stores the interfaces values from input file in the class file
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_interfaces(class_file &class_f, ifstream &file);

/**
 * @brief Stores the fields values from input file in the class file
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_fields(class_file &class_f, ifstream &file);

/**
 * @brief Stores the methods values from input file in the class file
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_methods(class_file &class_f, ifstream &file);

/**
 * @brief Stores the attributes values from input in the class file
 * 
 * @param class_f a reference to the class_file struct
 * @param file a reference to the input file stream
 */
void get_attributes(class_file &class_f, ifstream &file);

/**
 * @brief Returns the true value of a long number
 * 
 * @param high the first 4 bytes of the long number
 * @param low the last 4 bytes of the long number
 * @return long the converted number
 */
long calc_long(u4 high, u4 low);

/**
 * @brief Returns the true value of a double number
 * 
 * @param high the first 4 bytes of the double number
 * @param low the last 4 bytes of the double number
 * @return double the converted number
 */
double calc_double(u4 high, u4 low);

/**
 * @brief Returns the true value of a float number
 * 
 * @param bytes the 4 bytes of the float number
 * @return float the converted number
 */
float calc_float(u4 bytes);

#endif // _CLASS_FILE_HPP